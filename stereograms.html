<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">

<script>

screenWidthMillis = 600
distanceToScreenMillis = 1000

const depthMillis = 2000

//--------------------------------------------------------------
let vertexShaderSrc = `#version 300 es

in vec4 pos;
in vec4 color;

uniform mat4 projectionViewMatrix;

out vec4 f_color;

void main() {
    gl_Position = projectionViewMatrix * pos;
    f_color = color;
}
`

//--------------------------------------------------------------
let fragmentShaderSrc = `#version 300 es
precision highp float;

out vec4 FragColor;
in vec4 f_color;

void main() {
    FragColor = f_color;
}
`

//--------------------------------------------------------------
let mainProgram = {
    shaders: [
        { type: "VERTEX_SHADER", src: vertexShaderSrc, },
        { type: "FRAGMENT_SHADER", src: fragmentShaderSrc, }
    ],
    
    uniforms: {
        projectionViewMatrix: null,
    },
    
    vertexSpecification: [
        // attributes, located in the same buffer
        // {
        //     type: "FLOAT", // type of values in buffer
        //     attributes: [
        //         {
        //             name: "AttributeName",
        //             sizeUnits: 4,
        //             offsetUnits: 0 //  OPTIONAL, offset in units (not in bytes), default automatic
        //             strideUnits: 0 //  OPTIONAL, stride in units (not in bytes), default automatic over all attributes in buffer
        //             normalized: 0  //  OPTIONAL, default false
        //         },
        //     ]
        //     buffer:        //  OPTIONAL, explicit buffer specification, default automatic buffer allocation
        // },
        {
            type: "FLOAT",
            attributes: [
                {
                    name: "pos",
                    sizeUnits: 4,
                },
                {
                    name: "color",
                    sizeUnits: 4,
                },
            ]
        },
    ]
}

//--------------------------------------------------------------
class BufferBuilder {
    constructor(program) {
        if (!program.ready) throw new Error('Program is not compiled yet')
        
        this.program = program
        this.size = 0
        this.vertexArrays = program.vertexSpecification.map(x => new Array)
        
        this.indexBuffer = program.gl.createBuffer()
        this.drawcalls = {}
    }
    
    clear() {
        for ( let vertexArray of this.vertexArrays ) vertexArray.length = 0
        
        this.size = 0
        this.drawcalls = {}
    }
    
    addVertex(vertex, index) {
        if ( index === undefined ) {
            index = this.size
        }
        for ( let i = 0; i < this.program.vertexSpecification.length; i++ ) {
            let vertexArray = this.vertexArrays[i]
            for ( const attr of this.program.vertexSpecification[i].attributes ) {
                let vertexAttr = vertex[attr.name]
                if ( vertexAttr===undefined ) throw new Error(`"${attr.name}" required in vertex specification`)
                if ( vertexAttr[0]===undefined ) vertexAttr = [vertexAttr]
                if ( vertexAttr.length != attr.sizeUnits) {
                    throw new Error(`"${attr.name}" attribute must be of lenth ${attr.sizeUnits}`)
                }
                for ( let k = 0; k < attr.sizeUnits; k++ ) {
                    vertexArray[attr.offsetUnits + index*attr.strideUnits + k] = vertexAttr[k]
                }
            }
        }
        
        if ( index >= this.size ) this.size = index + 1;
        
        return index
    }
    
    addIndices(name, type, ...indices) {
        if ( !this.drawcalls[name] ) {
            this.drawcalls[name] = {
                indices: [],
                type: type,
            }
        } else {
            if ( this.drawcalls[name].type != type ) throw new Error('Drawcall type mismatch')
        }
        
        this.drawcalls[name].indices.push(...indices)
    }
    
    uploadData() {
        let gl = this.program.gl
        
        gl.useProgram(this.program.program)
        
        for ( let i = 0; i < this.program.vertexSpecification.length; i++ ) {
            let spec = this.program.vertexSpecification[i]
            
            gl.bindBuffer(gl.ARRAY_BUFFER, spec.buffer)
            gl.bufferData(
                gl.ARRAY_BUFFER,
                new dataTypes[spec.type].arrayType(this.vertexArrays[i]),
                gl.STATIC_DRAW
            )
        }
        
        let pos = 0
        let dataType = 'UNSIGNED_SHORT'
        for ( let drawcall of Object.values(this.drawcalls) ) {
            drawcall.indexBuffer = this.indexBuffer
            drawcall.dataType = dataType
            drawcall.start = pos
            drawcall.count = drawcall.indices.length
            pos += drawcall.count
            drawcall.program = this.program
            drawcall.draw = function() {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer)
                gl.drawElements(
                    gl[this.type],
                    this.count,
                    gl[this.dataType],
                    this.start * dataTypes[this.dataType].size
                )
            }
        }
        
        let allIndices = new dataTypes[dataType].arrayType(pos)
        for ( let drawcall of Object.values(this.drawcalls) ) {
            allIndices.set(drawcall.indices, drawcall.start)
        }
        
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer)
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, allIndices, gl.STATIC_DRAW)
        
        // this.clear()
        return this.drawcalls
    }
}

//--------------------------------------------------------------
function resolveConstant(gl, value) {
    return typeof value == 'string' ? gl[value] : value
}

//--------------------------------------------------------------
const dataTypes = {
    BYTE:           { size: 1, arrayType: Int8Array },
    UNSIGNED_BYTE:  { size: 1, arrayType: Uint8Array },
    SHORT:          { size: 2, arrayType: Int16Array },
    UNSIGNED_SHORT: { size: 2, arrayType: Uint16Array },
    INT:            { size: 4, arrayType: Int32Array },
    UNSIGNED_INT:   { size: 4, arrayType: Uint32Array },
    FLOAT:          { size: 4, arrayType: Float32Array },
}

//--------------------------------------------------------------
function buildProgram(gl, program) {
    program.program = gl.createProgram()
    
    for ( let shader of program.shaders ) {
        shader.shader = gl.createShader(resolveConstant(gl, shader.type))
        gl.shaderSource(shader.shader, shader.src)
        gl.compileShader(shader.shader)
        if ( !gl.getShaderParameter(shader.shader, gl.COMPILE_STATUS) ) {
            console.log(`Compile error: ${gl.getShaderInfoLog(shader.shader)}`)
        }
        gl.attachShader(program.program, shader.shader)
    }
    
    gl.linkProgram(program.program)
    
    for ( let shader of program.shaders ) {
        gl.deleteShader(shader.shader)
        delete shader.shader
    }
    
    if(!gl.getProgramParameter(program.program, gl.LINK_STATUS)) {
        const shaderError = gl.getProgramInfoLog(program.program)
        throw new Error(`Shader error: ${shaderError}`)
    }
    
    for ( let spec of program.vertexSpecification ) {
        if ( !spec.buffer ) spec.buffer = gl.createBuffer()
        
        gl.bindBuffer(gl.ARRAY_BUFFER, spec.buffer)
        const unitSize = dataTypes[spec.type].size
        let strideUnits = spec.attributes.reduce((accum, attr) => accum + attr.sizeUnits, 0)
        var offsetUnits = 0
        
        for ( let attr of spec.attributes ) {
            attr.location = gl.getAttribLocation(program.program, attr.name)
            if ( attr.location == -1 ) throw new Error(`Vertex attribut name not found: ${attr.name}`)
            
            if ( attr.offsetUnits === undefined ) attr.offsetUnits = offsetUnits
            if ( attr.strideUnits === undefined ) attr.strideUnits = strideUnits
            
            gl.vertexAttribPointer(
                attr.location,
                attr.sizeUnits,
                resolveConstant(gl, spec.type),
                attr.normalized,
                attr.strideUnits * unitSize,
                attr.offsetUnits * unitSize
            )
            gl.enableVertexAttribArray(attr.location)
            offsetUnits += attr.sizeUnits
        }
    }
    
    for ( let uniform in program.uniforms ) {
        program.uniforms[uniform] = gl.getUniformLocation(program.program, uniform)
        if ( program.uniforms[uniform] === null ) throw new Error(`Uniform not found: ${uniform}`)
    }
    
    program.gl = gl
    program.ready = true
}

//--------------------------------------------------------------


//============================================================
// Matrix functions


//--------------------------------------------------------------
function identity() {
    let mat = new Float32Array(16)
    mat[0] = mat[5] = mat[10] = mat[15] = 1.0
    return mat
}

//--------------------------------------------------------------
function frustum(left, right, bottom, top, near, far) {
    let mat = new Float32Array(16)
    
    mat[0] = 2 * near / (right - left)
    mat[1] = 0
    mat[2] = 0
    mat[3] = 0
    
    mat[4] = 0
    mat[5] = 2 * near / (top - bottom)
    mat[6] = 0
    mat[7] = 0
    
    mat[8] = (right + left) / (right - left)
    mat[9] = (top + bottom) / (top - bottom)
    mat[10] = - (far + near) / (far - near)
    mat[11] = -1
    
    mat[12] = 0
    mat[13] = 0
    mat[14] = - 2 * far * near / (far - near)
    mat[15] = 0
    
    return mat
}

//--------------------------------------------------------------
function mulMatrix(mat1, mat2) {
    let mat = new Float32Array(16)
    
    for (var row=0; row<4; row++) {
        for (var col=0; col<16; col+=4) {
            mat[row+col] = (
                mat1[row]      * mat2[col] + 
                mat1[row + 4]  * mat2[col + 1] + 
                mat1[row + 8]  * mat2[col + 2] + 
                mat1[row + 12] * mat2[col + 3]
            )
        }
    }
    
    return mat
}

//--------------------------------------------------------------
function translateInplace(mat, dx, dy, dz) {
    mat[12] += mat[0]*dx + mat[4]*dy + mat[8]*dz
    mat[13] += mat[1]*dx + mat[5]*dy + mat[9]*dz
    mat[14] += mat[2]*dx + mat[6]*dy + mat[10]*dz
    mat[15] += mat[3]*dx + mat[7]*dy + mat[11]*dz
}

//--------------------------------------------------------------
function rotateInplace(mat, axis1, axis2, angle) {
    let index1 = axis1 * 4
    let index2 = axis2 * 4
    let c = Math.cos(angle)
    let s = Math.sin(angle)
    for ( var i=0; i<4; i++ ) {
        let temp = mat[index1]*c + mat[index2]*s;
        mat[index2] = mat[index2]*c - mat[index1]*s;
        mat[index1] = temp;
        index1++;
        index2++;
    }
}


function printMatrix(m) {
    console.log('---------------')
    for ( let i of [0, 1, 2, 3] ) {
        console.log(m[i], m[i+4], m[i+8], m[i+12])
    }
}

// End of matrix functions
//============================================================

class Scene {
    constructor(gl) {
        this.initParams()
        
        this.mainProgram = mainProgram
        buildProgram(gl, this.mainProgram)
        
        let builder = new BufferBuilder(this.mainProgram)
        
        this.addCube(builder, 100)
        
        this.drawcalls = builder.uploadData()
    }
    
    addCube(builder, size) {
        let halfSize = size * 0.5
        function addFace(axis1, axis2, faceShift, color) {
            let pos = [0, 0, 0, 1]
            pos[axis1] = -halfSize
            pos[axis2] = -halfSize
            pos[3 - axis1 - axis2] = faceShift
            let v1 = builder.addVertex({ pos: pos, color: color })
            pos[axis1] *= -1
            let v2 = builder.addVertex({ pos: pos, color: color })
            pos[axis2] *= -1
            let v3 = builder.addVertex({ pos: pos, color: color })
            pos[axis1] *= -1
            let v4 = builder.addVertex({ pos: pos, color: color })
            builder.addIndices('objects_triangles', 'TRIANGLES', v1, v2, v3)
            builder.addIndices('objects_triangles', 'TRIANGLES', v3, v4, v1)
        }

        addFace(0, 1, halfSize, [1, 0, 0, 1])
        addFace(1, 0, -halfSize, [0, 1, 1, 1])
        addFace(1, 2, halfSize, [0, 1, 0, 1])
        addFace(2, 1, -halfSize, [1, 0, 1, 1])
        addFace(2, 0, halfSize, [0, 0, 1, 1])
        addFace(0, 2, -halfSize, [1, 1, 0, 1])
    }
    
    initParams() {
        this.distance = distanceToScreenMillis + depthMillis / 2
        this.alpha = 0
        this.beta = 0
    }
    
    draw() {
        let gl = this.mainProgram.gl
        
        gl.useProgram(this.mainProgram.program)
        
        let pvm = buildProjectionMatrix(gl)
        translateInplace(pvm, 0, 0, -this.distance)
        rotateInplace(pvm, 1, 2, this.beta)
        rotateInplace(pvm, 2, 0, this.alpha)
        
        gl.uniformMatrix4fv(
            this.mainProgram.uniforms.projectionViewMatrix,
            false,
            pvm
        )
        
        this.drawcalls.objects_triangles.draw()
    }
}

//--------------------------------------------------------------
function buildProjectionMatrix(gl) {
    let millisPerPixel = screenWidthMillis / screen.width
    
    let projectionMatrix = frustum(
        -gl.canvas.width * millisPerPixel / 2,
        gl.canvas.width * millisPerPixel / 2,
        -gl.canvas.height * millisPerPixel / 2,
        gl.canvas.height * millisPerPixel / 2,
        distanceToScreenMillis,
        distanceToScreenMillis + depthMillis
    )
    
    return projectionMatrix
}

//--------------------------------------------------------------
function setupGL(canvas) {
    let gl = canvas.getContext("webgl2")
    gl.clearColor(0.0, 0.0, 0.0, 1.0)
    gl.enable(gl.DEPTH_TEST)
    gl.enable(gl.CULL_FACE)
    return gl
}

//--------------------------------------------------------------
function updateViewParams() {
    let screenWidthElement = document.querySelector('#screenWidth')
    let distanceToScreenElement = document.querySelector('#distanceToScreen')
    screenWidthElement.value = screenWidthMillis
    distanceToScreenElement.value = distanceToScreenMillis
}

//--------------------------------------------------------------
function init() {
    updateViewParams()
    
    let canvas = document.querySelector('#canvas')
    let gl = setupGL(canvas)
    
    let scene = new Scene(gl)
    
    function draw() {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)
        scene.draw()
    }
    
    canvas.onwheel = (evt) => {
        const distCoef = 1.01
        if ( evt.wheelDelta > 0 ) scene.distance /= distCoef
        else if ( evt.wheelDelta < 0 ) scene.distance *= distCoef
        requestAnimationFrame(draw)
    }
    
    canvas.onpointerdown = (downEvt) => {
        canvas.setPointerCapture(downEvt.pointerId)
        
        let startAlpha = scene.alpha
        let startBeta = scene.beta
        
        canvas.onpointermove = (moveEvt) => {
            const xSensitivity = 0.015
            const ySensitivity = 0.015
            
            scene.alpha = startAlpha + (moveEvt.x - downEvt.x) * xSensitivity
            while ( scene.alpha < -Math.PI ) scene.alpha += Math.PI*2
            while ( scene.alpha > Math.PI ) scene.alpha -= Math.PI*2
            scene.beta = startBeta + (moveEvt.y - downEvt.y) * ySensitivity
            if ( scene.beta < -Math.PI*0.5 ) scene.beta = -Math.PI*0.5
            if ( scene.beta > Math.PI*0.5 ) scene.beta = Math.PI*0.5
            
            requestAnimationFrame(draw)
        }
    }
    
    canvas.onpointerup = (evt) => {
        canvas.onpointermove = null
        canvas.releasePointerCapture(evt.pointerId)
    }
    
    requestAnimationFrame(draw)
}

//--------------------------------------------------------------
</script>

</head>
<body onload="init()">
    <table>
        <tr><td>Screen width (mm)</td><td><input id="screenWidth" readonly="readonly" /></td></tr>
        <tr><td>Distance to screen (mm)</td><td><input id="distanceToScreen" readonly="readonly" /></td></tr>
    </table>
    
    <canvas id="canvas" width="1000" height="750" oncontextmenu="return false"></canvas>
</body>
</html>
